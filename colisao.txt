(function() {
    // 1. SinalizaÃ§Ã£o do Script
    const aviso = document.createElement('div');
    aviso.style = "position:absolute; bottom:40px; left:10px; background:#007bff; color:white; padding:5px; border-radius:5px; font-size:10px; z-index:10000; font-weight:bold;";
    aviso.innerText = "ðŸ›¡ï¸ COLISÃƒO AVANÃ‡ADA: ATIVA";
    document.body.appendChild(aviso);

    // 2. VariÃ¡veis de ColisÃ£o
    const wallRaycaster = new THREE.Raycaster();
    const collisionDist = 3.5; // DistÃ¢ncia da parede para ele parar

    // 3. Sobrescrever a lÃ³gica de movimento no loop principal (animate)
    // Vamos modificar a funÃ§Ã£o original injetando a checagem de parede
    const oldAnimate = window.animate;
    
    // Criamos uma nova lÃ³gica de movimento que substitui a simples
    window.checkWalls = function(nextPos) {
        if (!mapModel || !player) return nextPos;

        // DireÃ§Ãµes: Frente, TrÃ¡s, Esquerda, Direita
        const directions = [
            new THREE.Vector3(Math.sin(camRot), 0, Math.cos(camRot)), // Frente
            new THREE.Vector3(-Math.sin(camRot), 0, -Math.cos(camRot)), // TrÃ¡s
            new THREE.Vector3(Math.cos(camRot), 0, -Math.sin(camRot)), // Direita
            new THREE.Vector3(-Math.cos(camRot), 0, Math.sin(camRot))  // Esquerda
        ];

        let canMove = true;
        for (let dir of directions) {
            wallRaycaster.set(player.position, dir);
            const intersects = wallRaycaster.intersectObject(mapModel, true);
            
            if (intersects.length > 0 && intersects[0].distance < collisionDist) {
                // Se detectar parede muito perto na direÃ§Ã£o que estamos indo, bloqueia
                if (keys['KeyW'] && dir.z > 0.5) return player.position; 
                if (keys['KeyS'] && dir.z < -0.5) return player.position;
            }
        }
        return nextPos;
    };

    // Ajuste direto no loop de animaÃ§Ã£o para usar a nova trava
    const originalUpdate = animate;
    window.animate = function() {
        // Esta parte rodarÃ¡ dentro do requestAnimationFrame original
        if (player && mapModel && !fly) {
            // Se o player tentar entrar em algo, empurramos ele um pouco para trÃ¡s
            let origin = new THREE.Vector3(player.position.x, player.position.y + 2, player.position.z);
            let forward = new THREE.Vector3(Math.sin(camRot), 0, Math.cos(camRot));
            
            wallRaycaster.set(origin, forward.negate()); // Checa frente
            let hit = wallRaycaster.intersectObject(mapModel, true);
            
            if (hit.length > 0 && hit[0].distance < collisionDist) {
                // Se bater, anula a velocidade de movimento naquela direÃ§Ã£o
                player.position.addScaledVector(forward, 0.5); 
            }
        }
        originalUpdate();
    };

    console.log("Sistema de colisÃ£o pro-ativa injetado.");
})();
